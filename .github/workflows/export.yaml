name: Build & Export (matrix + usage)

on:
  push:
    branches: [ "master" ]
  workflow_dispatch: {}

env:
  TILE: 512
  OUT_DIR: data/minimaps
  TILE_DIR: data/tiles

jobs:
  # 1) Enumerate all .dmm maps and build a JSON matrix
  enumerate:
    runs-on: ubuntu-24.04
    outputs:
      maps_json: ${{ steps.mk.outputs.maps_json }}
      count: ${{ steps.mk.outputs.count }}
    steps:
      - uses: actions/checkout@v4
      - id: mk
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
      
          # Collect .dmm files from both trees
          files=()
          [ -d maps  ]  && while IFS= read -r -d '' f; do files+=("$f"); done < <(find maps  -type f -name '*.dmm' -print0 || true)
          [ -d _maps ] && while IFS= read -r -d '' f; do files+=("$f"); done < <(find _maps -type f -name '*.dmm' -print0 || true)
      
          if [ ${#files[@]} -eq 0 ]; then
            echo "No .dmm files under maps/ or _maps/"; exit 1
          fi
      
          # Build JSON [{path, id}, ...] then compress to one line
          first=1; json='['
          for f in "${files[@]}"; do
            rel="${f#./}"
            id="$(echo "$rel" | sed -E 's/\.dmm$//; s/[^A-Za-z0-9._-]+/_/g')"
            obj=$(jq -n --arg path "$rel" --arg id "$id" '{path:$path,id:$id}')
            if [ $first -eq 1 ]; then json="$json$obj"; first=0; else json="$json,$obj"; fi
          done
          json="$json]"
          json_compact=$(jq -c . <<<"$json")
          count=$(jq -r 'length' <<<"$json")
      
          # Write multi-line output with a heredoc (safe)
          {
            echo "maps_json<<JSON"
            echo "$json_compact"
            echo "JSON"
            echo "count=$count"
          } >> "$GITHUB_OUTPUT"
      
          echo "Found $count maps."

  # 2) Per-map job: render + tile + per-map index + usage
  export:
    needs: enumerate
    runs-on: ubuntu-24.04
    timeout-minutes: 45
    strategy:
      fail-fast: false
      max-parallel: 3
      matrix:
        map: ${{ fromJSON(needs.enumerate.outputs.maps_json) }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build SpacemanDMM
        run: |
          set -eux
          git clone --depth=1 https://github.com/SpaceManiac/SpacemanDMM /tmp/SpacemanDMM
          cd /tmp/SpacemanDMM && cargo build --release --bin dmm-tools
          echo "/tmp/SpacemanDMM/target/release" >> $GITHUB_PATH

      - name: Install ImageMagick + jq + numfmt
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick jq coreutils
          /usr/bin/convert -version | head -n1

      - name: Render minimaps (one PNG per Z)
        env:
          MAP_PATH: ${{ matrix.map.path }}
          MAP_ID:   ${{ matrix.map.id }}
        run: |
          set -euo pipefail
          mkdir -p "$OUT_DIR/$MAP_ID"
          echo "Rendering $MAP_PATH → $OUT_DIR/$MAP_ID"
          dmm-tools minimap "$MAP_PATH" -o "$OUT_DIR/$MAP_ID"
          ls -lh "$OUT_DIR/$MAP_ID" || true

      - name: Tile to ${TILE}×${TILE} (row,col from top-left) + per-map index.json
        env:
          MAP_ID: ${{ matrix.map.id }}
          MAP_PATH: ${{ matrix.map.path }}
        run: |
          set -euo pipefail
          mkdir -p "$TILE_DIR/$MAP_ID"
          zmeta='[]'
          for png in "$OUT_DIR/$MAP_ID"/*.png; do
            base="$(basename "$png")"
            z="${base%.*}"; z="${z##*-}"                 # MapName-3.png -> 3
            out="$TILE_DIR/$MAP_ID/z$z"
            mkdir -p "$out"

            # Crop into 512×512 tiles; name row,col.png (top-left origin); preserve RGBA; pad edges
            /usr/bin/convert "$png" \
              -colorspace sRGB -alpha on -type TrueColorAlpha -background none \
              -crop ${TILE}x${TILE} \
              -set filename:tile "%[fx:floor(page.y/${TILE})],%[fx:floor(page.x/${TILE})]" \
              +repage -gravity northwest -extent ${TILE}x${TILE} \
              +adjoin "$out/%[filename:tile].png"

            # z-level metadata from original PNG
            w=$(/usr/bin/identify -format '%w' "$png")
            h=$(/usr/bin/identify -format '%h' "$png")
            cols=$(( (w + TILE - 1) / TILE ))
            rows=$(( (h + TILE - 1) / TILE ))
            zmeta="$(jq -c \
              --arg z "$z" \
              --argjson w "$w" \
              --argjson h "$h" \
              --argjson rows "$rows" \
              --argjson cols "$cols" \
              --arg tile "$TILE" \
              '. + [{z:($z|tonumber), width_px:$w, height_px:$h, rows:$rows, cols:$cols, tile_size:($tile|tonumber)}]' \
              <<< "$zmeta")"
          done

          # Per-map index.json
          jq -n \
            --arg id "$MAP_ID" \
            --arg tiles_base "data/tiles/$MAP_ID" \
            --arg minimaps_base "data/minimaps/$MAP_ID" \
            --arg source_dmm "$MAP_PATH" \
            --argjson z_levels "$zmeta" \
            '{map_id:$id, source_dmm:$source_dmm, tiles_base:$tiles_base, minimaps_base:$minimaps_base, z_levels:$z_levels}' \
            > "$TILE_DIR/$MAP_ID/index.json"

      - name: Disk usage summary (per map)
        env:
          MAP_ID: ${{ matrix.map.id }}
        run: |
          set -euo pipefail
          tiles=$(find "$TILE_DIR/$MAP_ID" -type f -name '*.png' | wc -l | tr -d ' ')
          bytes=$(du -sb "$TILE_DIR/$MAP_ID" | awk '{print $1}')
          human=$(numfmt --to=iec --suffix=B "$bytes")
          echo "Tiles: $tiles  Size: $human"
          {
            echo "### Map \`$MAP_ID\`"
            echo ""
            echo "| Metric | Value |"
            echo "|---|---:|"
            echo "| PNG tiles | $tiles |"
            echo "| Disk usage | $human |"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload per-map artifact
        uses: actions/upload-artifact@v4
        with:
          name: tiles-${{ matrix.map.id }}
          path: |
            data/tiles/${{ matrix.map.id }}/**/*.png
            data/tiles/${{ matrix.map.id }}/index.json
          if-no-files-found: error

  # 3) Assemble: download all per-map artifacts and build a global catalog
  assemble:
    needs: export
    runs-on: ubuntu-24.04
    steps:
      - name: Download all map artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: tiles-*
          merge-multiple: true
          path: data/tiles

      - name: Build top-level tiles index.json
        run: |
          set -euo pipefail
          shopt -s nullglob
          tmp="data/tiles/_maps.json"
          jq -s '.' data/tiles/*/index.json > "$tmp"
          jq -n \
            --arg generated "$(date -u +%FT%TZ)" \
            --arg tile "512" \
            --slurpfile maps "$tmp" \
            '{generated_at:$generated, tile_size:($tile|tonumber), maps:$maps[0]}' \
            > data/tiles/index.json
          rm -f "$tmp"
          head -n 40 data/tiles/index.json

      - name: Upload global index
        uses: actions/upload-artifact@v4
        with:
          name: tiles-index-${{ github.sha }}
          path: data/tiles/index.json
          if-no-files-found: error
